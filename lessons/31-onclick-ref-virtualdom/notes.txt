Отлавливание пожеланий пользователя
Код внутри функции не выполняется до тех пор, пока эту функцию не вызовут.
Концепция callback - мы сами не вызываем функцию, а отдаем ее кому-то (например, обработчику события), чтобы ее вызвал кто-то другой.
Такая функция называются callback function (функция обратного вызова).
Нетривиальный - сложный.
В JS функция - это объект.
Функция - это объект, который можно вызвать и который будет выполнять какие-то действия (логику).
Можно представить функцию как «объект, который может делать какое-то действие».
Следовательно, функцию как объект можно передать кому-то другому. И ее вызовет этот кто-то другой.
Следует выносить функции (логику) за пределы JSX-кода.
addPost - так мы отдаем функцию кому-то на выполнение
addPost(); - так мы выполняем функцию сами
Когда мы отдаем функцию кому-то на выполнение, эта функция называется callback function (функция обратного вызова).
Например, мы отдаем callback function кнопке, а она обратно (в ответ) вызывает эту callback function, если по этой кнопке щелкнут:
<button onClick={ addPost }>Add post</button>
Задача UI - собрать все данные от пользователя и направить их на обработку в бизнес-уровень.
Разработчики React говорят: "Старайтесь избегать 'ref' ".
ref - ссылка
React быстрый. React очень шустрый VirtualDOM проецирует на обычный DOM.
В React нельзя обращаться к DOM напрямую. Например, нельзя вызывать методы:
- document.getElementById();
- document.getElementsByClassname();
- document.querySelector();
- addEventListener();
- и подобные.
Одна из причин в том, что мы не знаем в определенный момент времени, существует ли этот конкретный DOM или нет.
Вместо того, чтобы ссылаться на элемент по его id, в React надо делать так:
let newPostElement = React.createRef();
Ссылка создана, но еще не привязана ни к чему.
Чтобы привязать ссылку к тегу, делаем так:
<textarea ref={newPostElement}></textarea>
Как говорят: "textarea, эта ссылка будет ссылаться на тебя".
Таким образом, через переменную newPostElement мы может обратиться к textarea, как с помощью Vanilla JS обратились бы к нему с помощью "getElementById()".
Такая ссылка newPostElement является объектом.
Свойство current ссылается на нативный HTML-элемент.
let text = newPostElement.current.value;
Чтобы обратиться непосредственно к HTML-элементу, на который ссылается конкретная ссылка, нужно добавить к переменной ссылки свойство current.
С помощью ref мы стучимся напрямую к DOM элемента. А мы должны работать с VirtualDOM.
Обладая state (истиной), мы можем удалить все содержимое <App/> и заново отрисовать его.
При первичной загрузке страницы state передается в UI (props прокидываются по компонентам) 1 раз. Чтобы сделать этот цикл прокидывания props еще раз, надо препринять определенное действие. Им мы займемся в следующем уроке.






