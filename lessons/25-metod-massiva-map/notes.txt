Ctrl+/ - закомментировать строку (не выделяя)
Ctrl+Shift+/ (выделив код) - закомментировать выделенный фрагмент

Если прямо в JSX передать массив, тогда компилятор отобразит значения элементов массива один за другим:
{
    ['sdsd', '232323', 'itkamasutra']
}
Результат на странице:
sdsd232323itkamasutra

Помимо строк, чисел, объектов, в массиве может лежать React-компонент (jsx-компонент):
{
    [ <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />, '232323', 'itkamasutra' ]
}

{
    [
        <DialogItem name={dialogsData[0].name} id={dialogsData[0].id} />,
        <DialogItem name={dialogsData[1].name} id={dialogsData[1].id} />,
        <DialogItem name={dialogsData[2].name} id={dialogsData[2].id} />
    ]
}

Результат (2ой пример):
Dimych
Andrey
Sveta

map - составлять, сопоставлять; отображать; наносить на карту; "перебирать", преобразовать (массив)
mapping - преобразование; отображение; картография

map - преобразовать (массив)
mapping - преобразование (массива)



Метод массива "map()".

Метод map() преобразовывает один массив и в результате возвращает новый массив.
У любого массива можно вызвать метод "map()" для того, чтобы преобразовать массив одних элементов в массив других элементов.
[1,1,1,1,1,1].map(...)
Например, есть массив барашков, а мы хотим получить массив шерсти (клубков). То есть, на базе каждого барашка мы получили клубок. Исходный массив состоит из 4 барашков, результирующий массив состоит из 4 клубков. Каждый элемент в новом массиве получается как проекция старого. Старый элемент вносит вклад в то, как будет выглядеть новый элемент.
У нас есть массив имен. 1 - мужской пол, 0 - женский пол. Нужно преобразовать массив имен в массив полов.
[ "Dmitry", "Andrew", "Viktor", "Sveta", "Sasha" ]
преобразуем в
[ 1, 1, 1, 0, 0 ]
Либо преобразуем в теги
[ "<li>Dmitry</li>", "<li>Andrew</li>", "<li>Viktor</li>", "<li>Sveta</li>", "<li>Sasha</li>" ]

[ "blabla", "hello", "hi" ]
преобразуем в
[ { eng: "blabla", ru: "блабла" }, { eng: "hello", ru: "привет" }, { eng: "hi", ru: "здарова" } ]
Строка "blabla" вставляется в объект качестве значения свойства "eng".
То есть мы из массива трех строк получили массив из трех объектов, где каждый объект получен на основе соответствующей строки из исходного массива.

Посмотрим, как это пишется в JS.
Если нам надо сделать:
"[ "Dmitry", "Andrew", "Viktor", "Sveta", "Sasha" ]
 преобразуем в
 [ 1, 1, 1, 0, 0 ]"
Тогда мы пишем такой код:
let newArray = oldArray.map( (el) => {
if (isMaleName(el)) {
    return 1;
} else {
    return 0;
}
} );

Результат выполнения функции "map" - результат преобразования старого массива.
map() возвращает новый массив. map() принимает в себя стрелочную функцию. Единственный параметр функции map() - стрелочная функция.
Надо воспринимать эту стрелочную функцию как процессор (преобразователь). Эта стрелочная функция вызывается столько раз, сколько у нас элементов в исходном массиве.
И каждый раз в стрелочную функцию в качестве значения параметра "el" придет "Dmitry", затем "Andrew" и так далее.
Сюда будут приходить старые элементы, чтобы мы с ними что-то сделали и вернули из этой стрелочной функции новый элемент. Новый элемент и будет конкретным новым элементом нового массива.

ternary - тройной
Тернарное (условное) выражение
Тернарный оператор (ES6)
Выражение тернарного оператора
Before:
if (authenticated) {
  renderApp();
} else {
  renderLogin();
}

With Ternary
authenticated ? renderApp() : renderLogin();

На примере нашего массива зарефакторим код:
let newArray = oldArray.map( (el) => {
    return isMaleName(el) ? 1 : 0;
} );
Зарефакторим еще
let newArray = oldArray.map( (el) => isMaleName(el) ? 1 : 0; );

Когда в стрелочную функцию приходит 1 параметр, тогда можно убрать круглые скобки.
let newArray = oldArray.map( name => isMaleName(name) ? 1 : 0; );

"[ "Dmitry", "Andrew", "Viktor", "Sveta", "Sasha" ]
Преобразуем в теги
[ "<li>Dmitry</li>", "<li>Andrew</li>", "<li>Viktor</li>", "<li>Sveta</li>", "<li>Sasha</li>" ]

let newArray = oldArray.map(name => {
    return "<li>" + name + "</li>";
});

Синтаксис шаблонной строки (template variable).
let newArray = oldArray.map(name => {
    return `<li>${name}</li>`;
});

let newArray = oldArray.map(name => `<li>${name}</li>`; );

[ "blabla", "hello", "hi" ]
преобразуем в
[ { eng: "blabla", ru: "блабла" }, { eng: "hello", ru: "привет" }, { eng: "hi", ru: "здарова" } ]

let newArray = oldArray.map( el => {
    return {
        eng: el,
        ru: translateIntoRu(el)
    }
});

let newArray = oldArray.map( el => ({
        eng: el,
        ru: translateIntoRu(el)
    })
);

Чтобы вернуть объект без фигурных скобок (скобок тела функции) и без ключевого слова return, надо объект обернуть в круглые скобки.

let newArray = oldArray.map( word => ({
        eng: word,
        ru: translateIntoRu(word)
    })
);

Чаще всего будет так - у нас исходный массив с объектами, а результирующий массив будет с компонентами (JSX-элементами):
[ { eng: "blabla", ru: "блабла" }, { eng: "hello", ru: "привет" }, { eng: "hi", ru: "здарова" } ]
преобразуем в
[ <Message eng="blabla" ru="блабла" />, <Message eng="hello" ru="привет" />, <Message eng="hi" ru="здарова" /> ]

let newArray = oldArray.map( el => (<Message eng={el.eng} ru={el.ru} />) );
Или можно не обособлять компонент круглыми скобками
let newArray = oldArray.map( el => <Message eng={el.eng} ru={el.ru} /> );

Можно сокращать название элемента массива
let dialogsElements = dialogsData.map( dialog => <DialogItem name={dialog.name} id={dialog.id} /> );
let dialogsElements = dialogsData.map( d => <DialogItem name={d.name} id={d.id} /> );

occur - происходить, иметь место, встречаться
occurrence - возникновение, появление, наступление; происшествие

Выделяю переменную, жму Shift+F6, выбираю "Rename code occurrences", меняю имя переменной, жму Esc.
Т.о. имя переменной изменится везде в коде.
