Hooks решают те вещи, которые можно было решить с помощью классовых компонентов.
index.js - первая точка входа JS.
Webpack - это сборщик модулей JavaScript с открытым исходным кодом. Он создан в первую очередь для JavaScript, но может преобразовывать внешние ресурсы, такие как HTML, CSS и изображения, если включены соответствующие загрузчики. webpack принимает модули с зависимостями и генерирует статические ресурсы, представляющие эти модули.
Перед тем, как попасть в браузер, на этапе транспиляции Babel транспилирует (превращает) JSX-разметку в обычные JS-команды React.js ("React.createElement" и т.п.).
Т.е., в браузер должен попасть обычный JS. И браузер начинает выполнять наше приложение.
SPA - загружается одна страница HTML.
Помимо BrowserRouter есть еще HashRouter.
https://v5.reactrouter.com/web/api/HashRouter
https://coderoad.ru/51974369/HashRouter-%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2-BrowserRouter

hash - мешанина, путаница; крошево; крошить; рубить (мясо)
hash - крошево
Раньше технологии не позволяли менять адрес в браузере без перезагрузки страницы. Поэтому раньше использовался hash (#), "якорь". Например, "localhost:3000/#abcdef".
На практике HashRouter почти не используется.
Компонент NavLink меняет URL в браузере без перезагрузки страницы.
<Route /> и <NavLink /> не зависят друг от друга.
Ctrl+Alt+Left-Arrow - вернуться в предыдущий файл.
Библиотека react-redux предоставляет полезную функцию connect (рассмотрим в дальнейшем).
Технология по организации стилей - styled components.
Пользователь нажал на кнопку -  мы отправляем из UI action в state.
Предпочтительнее начинать разработку со state.
Общаясь с заказчиком, понимаем, какие сущности есть на страницах, и для каждой страницы мы делаем свое состояние (state): какие будут сущности, хранение (данные), какие будут actions.
Формируя state, отталкиваемся визуально от UI.
Сформировав state, мы идем в UI.
Принцип следующий: сделали state для одной страницы, затем сделали для нее UI, и т.д.
В будущем в state за каждую отдельную часть state (отвечающую за конкретную страницу) будет отвечать функция reducer.
reducer - редуктор, преобразователь данных; понизитель
reducer - преобразователь данных

redux - brought back; revived; "возвращение"
redux - "возвращение"
state всегда меняется только через dispatch(action).
Redux анализирует action, смотрит совпадение. Обычно в dispatch используют не if/else if statement, а switch (switch-case) statement:
https://www.w3schools.com/js/js_switch.asp
объект storeBeforeRealRedux - менеджер состояния
_callSubscriber() сообщает внешнему миру о том, что state изменился.
Меняем что-то в state, вызываем _callSubscriber().
_callSubscriber() - простая реализация паттерна observer (subscriber).
Рисовать схемы приложения.
Выделяем, например, "{messagesElements}", жмем Ctrl+Alt+J, далее Enter, и пишем div.
ref (в textarea и т.п.) мы будем стараться избегать.
e, event - объект события
С помощью "e" можно достучаться до объекта, с которым произошло событие.
e.target - в качестве target выступает textarea.
plain object - простой объект

let onNewMessageChange = (e) => {
  let body = e.target.value;
  props.storeBeforeRealRedux.dispatch(updateNewMessageBodyCreator(body));
};

Лучше передавать в объект props компонента следующие свойства:
<Profile
  profilePage={props.state.profilePage}
  dispatch={props.dispatch}
/>
т.е., часть state, а не весь storeBeforeRealRedux.
А кидать весь storeBeforeRealRedux в компонент - не очень правильно:
<Dialogs
  storeBeforeRealRedux={props.storeBeforeRealRedux}
/>

