Функции, передаваемые (в качестве значения атрибутов) в компонент App - это callback functions.
Циклическая зависимость
Циркулярная зависимость
Пример callback function.
subscribe(rerenderEntireTree);
При вызове одной функции мы в аргументе передаем другую функцию. То есть, внутри одной функции мы передаем другую функцию.
Замыкание функции
Замыкание функции - это, когда, например, в функции 1 есть вызов функции 2, но эта функция 2 не лежит в функции 1. Тогда функция 1 начинает искать функцию 2 за пределами своей области видимости - теперь в глобальной области видимости текущего файла JS.
Замыкание работает так: мы выпрыгиваем из функции 1 и ищем функцию 2 в родителькой области видимости (parent scope), в глобальной области видимости. При этом мы не имеем права, в поисках функции 2, залезать внуть других функций в файле.
Если внутри функции создать переменную, тогда эта переменная остается "жить" внутри этой функции (будет работать (доступна) в локальной области видимости). Когда функция отработала, переменная "умерла", т.е. данные "умерли".
export const subscribe = (observer) => {
  rerenderEntireTree = observer;
};
в качестве параметра observer мы передаем функцию.
У нас будет такая договоренность - при вызове функций мы не будем передавать в качестве аргумента переменную state (объект состояния). Так работает Redux, туда не приходит ничего (не приходит state).
observer - это функция-наблюдатель (по аналогии со слушателем события) - наблюдает за объектом. И когда с объектом что-то происходит, этот наблюдатель уведомляется, что что-то произошло. Это pattern (проектирования).
Паттерн observer во многом похож на паттерн publisher-subscriber.
По паттерну observer работает метод addEventListener(). По этому же паттерну работают обработчики события onClick, onChange и т.п.
Изучить паттерны (проектирования):
https://habr.com/ru/company/ruvds/blog/427293/
https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9
https://habr.com/ru/post/132472/
https://www.digitalocean.com/community/tutorial_series/javascript-design-patterns
Ради удобства разработки на ближайшее время вернем state в аргумент rerenderEntireTree().
==
Это был важный рефакторинг кода. Он нас избавил от лишнего файла render.js.
Далее мы будем внедрять очень важного игрока - объект storeBeforeRealRedux. Это уже ООПшный объект.
state - тупой объект, в нем только хранятся данные.
VirtualDOM
Методы жизненного цикла
setState
Что важное - мы изучаем архитектурные принципы.


