Краткий ликбез по ООП

https://www.w3schools.com/js/js_object_methods.asp

const person = {
  firstName: "John",
  lastName: "Doe",
  id: 5566,
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
};

https://www.digitalocean.com/community/tutorials/how-to-use-object-methods-in-javascript-ru

const job = {
  position: 'cashier',
  type: 'hourly',
  isAvailable: true,
  showDetails() {
    const accepting =
      this.isAvailable ? 'is accepting applications' : "is not currently accepting applications";
    console.log(`The ${this.position} position is ${this.type} and ${accepting}.`);
  }
};

===

Чтобы объект был не тупым, а умным, ООПшным, у него должны быть не только строки/числа, но и методы (например, sayName()). Такой метод работает с внутренними данными объекта.

let man = {
  name: 'Dmitry',
  age: 31,
  sayName() {
    alert(this.name);
  }
};

console.log(man.age);
console.log(man.name);
man.sayName();

let page = {
  title: 'samuraiJS',
  content: ``,
  render() {
    document.title = this.title;
    document.write(this.content);
  }
};

page.content = `<div>Content about React JS</div>`;
page.render();

Транспиляция — преобразование программы, при котором используется исходный код программы, написанной на одном языке программирования в качестве исходных данных, и производится эквивалентный исходный код на другом языке программирования.
https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BF%D0%B0%D0%B9%D0%BB%D0%B5%D1%80
Транспиляция из JSX в JS.

Взаимодействуем с объектом как бы через рычажки благодаря его свойствам и методам. Все свойства и методы объекта - это и есть его интерфейс.
Код метода render() спрятан (инкапсулирован) внутри объекта, чтобы пользователю объекта было проще с ним взаимодействовать. Взаимодействуем с объектом только через интерфейс (не залезаем под капот).
У объектов с данными страниц веб-приложения интерфейс (набор свойств и методов) одинаковый.
Инкапсуляция - это сокрытие деталей. Т.е., это, когда мы инкапсулируем какую-то логику где-то в чем-то, обычно в объектах (или в методах).
Инкапсулировать логику - скрыть детали от внешнего человека.
В классовых компонентах мы определяем метод render().
В React JS много магии, но вся она инкапсулирована. Мы используем только заданные свойства и методы (интерфейс), созданные в React. Например, state или setState().
Часто мы хотим обезопасить наши данные. "Свойство объекта, ты являешься приватным. Не нужно тобой пользоваться напрямую". При создании своего объекта, чтобы создать такое свойство, мы ставим знак подчеркивания перед именем свойства. Тем самым мы говорим внешнему пользователю: "Это свойство не является интерфейсом. Не пользуйся, пожалуйста, им напрямую". Это не ограничивает внешнего человека от использования этого свойства.
Приватные свойства (методы) созданы для внутреннего пользования (пользования внутри объекта).
Внешний мир - это когда мы пользуемся объектом через внешнюю ссылку, например, page2._content.
Мы не можем присвоить значение свойству "_content" напрямую, как обычно.
Но мы можем присвоить значение этому свойству через метод-setter - setContent().
set - устанавливать, задавать
setter - задатчик; механизм для установки; "установщик", "устанавливающий", "задающий"
setter - установщик

setter - это метод, который устанавливает значение какому-либо свойству объекта (как правило, приватному свойству).
setContent(value) {
  this._content = value;
}
Отдельный setter создается для отдельного приватного свойства объекта.
setter-ы и getter-ы есть и в нативном JS.
Благодаря setter-ам у нас больше контроля над свойством - можно логировать изменения свойства (log), блокировать атаки, если контент опасный (exception).
setContent(value) {
  // log
  // value is dangerous SSX throw new exception
  this._content = value;
}
setter и getter нужны, чтобы инкапсулировать (скрыть) чрезмерные детали.

Внутри объекта можно обращаться к его приватному свойству.

getter - получатель; добытчик, приобретатель
getter - получатель

let page2 = {
  title: 'samuraiJS',
  _content: ``,
  setContent(value) {
    this._content = value;
  },
  getContent() {
    return this._content;
  },
  render: function() {
    document.write(this._content);
  }
};

приватному свойству нельзя задавать значение напрямую
page2._content = `<div>Content about React JS</div>`;
console.log(page2._content);
надо задавать значение приватного свойства через setter
page2.setContent(`<div>Content about React JS</div>`);
console.log(page2.getContent());
page2.render();

getter возвращает значение приватного свойства.

let store = {
  _subscriber() {
    console.log('no subscribers (observers)');
  },
  _state: {
    firstName: 'it-incubator.by',
    lastName: 'it-kamasutra.com'
  },
  getState() {
    return this._state;
  },
  subscribe(observer) {
    this._subscriber = observer;
  },
  setFirstName(value) {
    this._state.firstName = value;
    this._subscriber();
  }
};

let state = store.getState();
store.setFirstName('samuraiJS.com');
state = store.getState();

ООП логику и данные упаковывает в другой объект.
Метод subscribe() - такой же, как и в нашем проекте. Благодаря нему идет перерисовка DOM.
Функция, переданная в параметре или аргументе - это callback function.

Код для внешнего наблюдателя:

let state = store.getState();
store.setFirstName('samuraiJS.com');
state = store.getState();

store.subscribe( () => {
    let state = store.getState();
    renderPage(state);
  }
);

store.setFirstName('youtube.com');

Объект в отношении свойств и методов является как бы управленцем.
subscribe() берет новый state и с помощью renderPage() перерисовывает DOM, который теперь с изменениями благодаря изменениям в state.
Мы вызываем setFirstName(), и автоматически вызывается метод subscribe().
==
Конкретное видео про ООП - Ликбез из тачилы:
https://www.youtube.com/watch?v=spTyL4QK1KI&ab_channel=IT-KAMASUTRA

Ликбез из тачилы (плейлист):
https://www.youtube.com/watch?v=XsFcuM8mxco&list=PLcvhF2Wqh7DMGR08yA6oNKJ7WCM0tGd4z&ab_channel=IT-KAMASUTRA

Видео про ООП (Плейлист В деталях):
https://www.youtube.com/watch?v=kfW2_XE6-UU&list=PLcvhF2Wqh7DN2nTU8Q10SvAn4k8NpMJvh&ab_channel=IT-KAMASUTRA
==
Мыслить по функциональному подходу и по ООП.
Надо кодить по ООП.
==
Задание
Положить в store.js все в объект store. Экспортируем store во внешний мир. Импортируем его в index.js. В index.js в компоненте App вместо state - запросить state у store - указать метод getState(). Передать store целиком: store={store}. Когда надо будет в компонентах выполнить операцию, пишем: store.addPost и т.д.
Допустим, в MyPosts.jsx:
let addPost = () => {
  props.store.addPost();
};
Надо передать store и state в самую глубину.
state можно не передавать отдельно, а просто запрашивать этот state у объекта store.
==
React-Redux - библиотека.
Жизненный принцип: если я компонент и мне не нужен весь state, а мне нужна часть state, то не давайте мне в props весь state.
Для App нужен весь state. Для Dialogs мы передаем только часть state - свойство dialogsPage.
Каждый компонент должен получать только то, что ему конкретно надо, а не весь state.

store - хранить; магазин, склад; хранилище
store - хранилище

==
Задание по переходу на ООП (store.js) сделано частично - приложение работает, компоненты отображаются, но, например, функционал добавления постов и сообщений не работает (исправить этот баг в будущем).
